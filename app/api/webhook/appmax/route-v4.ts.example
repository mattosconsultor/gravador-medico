import { NextRequest, NextResponse } from 'next/server'
import { createClient } from '@supabase/supabase-js'
import { sendPurchaseEvent } from '@/lib/meta-capi'
import {
  syncCustomerFromAppmax,
  syncProductFromAppmax,
  createOrUpdateSaleFromAppmax,
  saveSaleItems,
  createCRMContactFromSale,
  updateCustomerMetrics,
  updateProductMetrics,
} from '@/lib/appmax-sync'

/**
 * =============================================
 * WEBHOOK APPMAX - V4.0 COMPLETO
 * =============================================
 * ‚úÖ Sincroniza√ß√£o completa: Customers, Products, Sales, CRM
 * ‚úÖ Usa fun√ß√µes utilit√°rias modulares
 * ‚úÖ Atualiza m√©tricas agregadas
 * ‚úÖ Meta CAPI integrado
 * ‚úÖ Logs detalhados
 * =============================================
 */

// Cliente Supabase ADMIN (ignora RLS)
const supabaseAdmin = process.env.SUPABASE_SERVICE_ROLE_KEY 
  ? createClient(
      process.env.NEXT_PUBLIC_SUPABASE_URL!,
      process.env.SUPABASE_SERVICE_ROLE_KEY,
      {
        auth: {
          autoRefreshToken: false,
          persistSession: false
        }
      }
    )
  : null

// Mapeia status da Appmax para nosso banco
function mapStatusToDatabase(appmaxStatus: string): string {
  const statusMap: Record<string, string> = {
    'pending': 'pending',
    'approved': 'approved',
    'paid': 'approved',
    'processing': 'pending',
    'refunded': 'refunded',
    'canceled': 'refused',
    'payment_not_authorized': 'refused',
    'refused': 'refused',
  }
  return statusMap[appmaxStatus.toLowerCase()] || 'pending'
}

export async function POST(request: NextRequest) {
  const startTime = Date.now()
  
  console.log('üîî ============================================')
  console.log('üîî WEBHOOK APPMAX V4.0 RECEBIDO:', new Date().toISOString())
  console.log('üîî ============================================')
  
  try {
    // Verificar se o Supabase Admin est√° configurado
    if (!supabaseAdmin) {
      console.error('‚ùå SUPABASE_SERVICE_ROLE_KEY n√£o configurada!')
      return NextResponse.json(
        { error: 'Servidor mal configurado' },
        { status: 500 }
      )
    }

    // Ler o corpo da requisi√ß√£o
    const body = await request.json()
    
    console.log('üì¶ Payload recebido:', JSON.stringify(body, null, 2))
    console.log('üîî Evento:', body.event || 'unknown')

    // IP de origem
    const ipAddress = request.headers.get('x-forwarded-for') || 
                     request.headers.get('x-real-ip') || 
                     'unknown'
    
    console.log('üîê IP:', ipAddress)

    // 1Ô∏è‚É£ SALVAR LOG (AUDITORIA)
    const { data: webhookLog } = await supabaseAdmin
      .from('webhooks_logs')
      .insert({
        source: 'appmax',
        event_type: body.event || body.status || 'unknown',
        ip_address: ipAddress,
        user_agent: request.headers.get('user-agent'),
        payload: body,
        processed: false,
      })
      .select()
      .maybeSingle()

    console.log('‚úÖ Log salvo:', webhookLog?.id)

    // 2Ô∏è‚É£ EXTRA√á√ÉO SEGURA DE DADOS
    const data = body.data || body.order || body
    
    if (!data.id && !body.order_id && !body.id) {
      console.log('‚ö†Ô∏è Webhook sem ID - Ignorando')
      return NextResponse.json({ message: 'Sem ID' }, { status: 200 })
    }

    const orderId = (data.id || body.order_id || body.id)?.toString()

    // Cliente (pode vir null)
    const customer = data.customer || body.customer || {}
    const customerName = customer.firstname 
      ? `${customer.firstname} ${customer.lastname || ''}`.trim()
      : (customer.name || body.name || 'Cliente Desconhecido')
    
    const customerEmail = customer.email || body.email || 'email@naoinformado.com'
    const customerPhone = customer.telephone || customer.phone || body.phone || null
    const customerCpf = customer.cpf || body.cpf || null

    // Status e Valores
    const eventType = body.event || ''
    const rawStatus = data.status || body.status || 'pending'
    const orderStatus = (eventType.toLowerCase().includes('paid') || eventType.toLowerCase().includes('authorized'))
      ? 'approved' 
      : mapStatusToDatabase(rawStatus)
    
    const totalAmount = parseFloat(data.total || data.full_payment_amount || body.total || body.amount || 0)
    const discount = parseFloat(data.discount || body.discount || 0)
    const subtotal = totalAmount + discount
    const paymentMethod = (data.payment_type || data.payment_method || body.payment_method || 'pix').toLowerCase()

    // Produtos
    const products = data.products || body.products || data.items || body.items || []

    // UTM
    const utmSource = body.tracking?.utm_source || body.utm_source || null
    const utmCampaign = body.tracking?.utm_campaign || body.utm_campaign || null
    const utmMedium = body.tracking?.utm_medium || body.utm_medium || null

    console.log('üìã Dados extra√≠dos:', {
      orderId,
      event: body.event,
      email: customerEmail,
      name: customerName,
      rawStatus,
      finalStatus: orderStatus,
      total: totalAmount,
      payment: paymentMethod,
      products: products.length,
    })

    // 3Ô∏è‚É£ SINCRONIZAR CLIENTE
    const { customer_id, error: customerError } = await syncCustomerFromAppmax(supabaseAdmin, {
      customer_id: (customer.id || body.customer_id)?.toString(),
      name: customerName,
      email: customerEmail,
      phone: customerPhone,
      cpf: customerCpf,
      utm_source: utmSource,
      utm_campaign: utmCampaign,
      utm_medium: utmMedium,
    })

    if (customerError) {
      console.warn('‚ö†Ô∏è Erro ao sincronizar cliente (continuando):', customerError)
    }

    // 4Ô∏è‚É£ CRIAR/ATUALIZAR VENDA
    const { sale, error: saleError } = await createOrUpdateSaleFromAppmax(supabaseAdmin, {
      appmax_order_id: orderId,
      customer_id: customer_id,
      customer_name: customerName,
      customer_email: customerEmail,
      customer_phone: customerPhone,
      customer_cpf: customerCpf,
      total_amount: totalAmount,
      discount: discount,
      subtotal: subtotal,
      status: orderStatus,
      payment_method: paymentMethod,
      utm_source: utmSource,
      utm_campaign: utmCampaign,
      utm_medium: utmMedium,
      ip_address: ipAddress,
      metadata: {
        raw_webhook: body,
        event_type: body.event,
        processing_time_ms: Date.now() - startTime,
      },
    })

    if (saleError || !sale) {
      console.error('‚ùå Erro cr√≠tico ao salvar venda:', saleError)
      throw saleError
    }

    console.log('‚úÖ Venda salva:', sale.id, '- Status:', sale.status)

    // 5Ô∏è‚É£ SALVAR ITENS DA VENDA
    if (products && products.length > 0) {
      const productsFormatted = products.map((product: any, index: number) => ({
        sku: product.sku || product.id?.toString() || `product_${index}`,
        product_id: product.id?.toString(),
        name: product.name || 'Produto',
        price: parseFloat(product.price || 0),
        quantity: parseInt(product.qty || product.quantity || 1),
        type: index === 0 ? 'main' : 'bump',
      }))

      const { success: itemsSuccess, error: itemsError } = await saveSaleItems(
        supabaseAdmin,
        sale.id,
        productsFormatted
      )

      if (itemsError) {
        console.warn('‚ö†Ô∏è Erro ao salvar itens (continuando):', itemsError)
      }

      // Atualizar m√©tricas dos produtos
      for (const prod of productsFormatted) {
        const { product_id } = await syncProductFromAppmax(supabaseAdmin, prod)
        if (product_id) {
          await updateProductMetrics(supabaseAdmin, product_id)
        }
      }
    }

    // 6Ô∏è‚É£ CRIAR/ATUALIZAR CONTATO CRM
    if (customer_id) {
      const { contact_id, error: crmError } = await createCRMContactFromSale(supabaseAdmin, {
        customer_id: customer_id,
        customer_name: customerName,
        customer_email: customerEmail,
        customer_phone: customerPhone,
        total_amount: totalAmount,
        status: orderStatus,
      })

      if (crmError) {
        console.warn('‚ö†Ô∏è Erro ao criar contato CRM (continuando):', crmError)
      }

      // Atualizar m√©tricas do cliente
      await updateCustomerMetrics(supabaseAdmin, customer_id)
    }

    // 7Ô∏è‚É£ ATUALIZAR LOG COMO SUCESSO
    if (webhookLog?.id) {
      await supabaseAdmin
        .from('webhooks_logs')
        .update({
          processed: true,
          success: true,
          processed_at: new Date().toISOString(),
        })
        .eq('id', webhookLog.id)
    }

    // 8Ô∏è‚É£ üöÄ ENVIAR EVENTO PARA META CAPI (Se venda aprovada)
    if (orderStatus === 'approved' && totalAmount > 0) {
      console.log('üöÄ Enviando convers√£o para Meta CAPI...')
      
      // Buscar dados de tracking (fbp, fbc)
      let trackingData = { fbc: null, fbp: null, ipAddress, userAgent: null }
      
      if (customerEmail) {
        const { data: visits } = await supabaseAdmin
          .from('analytics_visits')
          .select('fbc, fbp, ip_address, user_agent')
          .ilike('referrer', `%${customerEmail}%`)
          .order('created_at', { ascending: false })
          .limit(1)
          .maybeSingle()
        
        if (visits) {
          trackingData = {
            fbc: visits.fbc,
            fbp: visits.fbp,
            ipAddress: visits.ip_address || ipAddress,
            userAgent: visits.user_agent
          }
        }
      }

      const metaResult = await sendPurchaseEvent({
        orderId: orderId,
        customerEmail: customerEmail !== 'email@naoinformado.com' ? customerEmail : undefined,
        customerPhone: customerPhone || undefined,
        customerName: customerName !== 'Cliente Desconhecido' ? customerName : undefined,
        totalAmount: totalAmount,
        currency: 'BRL',
        productName: products[0]?.name || 'Gravador M√©dico',
        productIds: products.map((p: any) => p.sku || p.id?.toString()).filter(Boolean),
        fbc: trackingData.fbc || undefined,
        fbp: trackingData.fbp || undefined,
        ipAddress: trackingData.ipAddress || undefined,
        userAgent: trackingData.userAgent || undefined,
        eventSourceUrl: 'https://www.gravadormedico.com.br'
      })

      if (metaResult.success) {
        console.log('‚úÖ Convers√£o enviada para Meta CAPI:', metaResult.fbTraceId)
      } else {
        console.error('‚ö†Ô∏è Falha ao enviar para Meta CAPI:', metaResult.error)
      }
    }

    console.log(`‚úÖ Webhook processado em ${Date.now() - startTime}ms`)
    console.log('üéâ ============================================')

    return NextResponse.json({
      success: true,
      message: 'Venda registrada e sincronizada',
      sale_id: sale.id,
      customer_id: customer_id,
      processing_time_ms: Date.now() - startTime,
    })

  } catch (error: any) {
    console.error('‚ùå Erro cr√≠tico:', error)
    
    // Retorna 200 para Appmax n√£o ficar reenviando
    return NextResponse.json(
      { 
        error: 'Erro processado', 
        message: error.message,
      },
      { status: 200 }
    )
  }
}

// Endpoint GET para testar
export async function GET() {
  return NextResponse.json({
    message: 'Webhook APPMAX v4.0 - Sincroniza√ß√£o Completa',
    timestamp: new Date().toISOString(),
    status: 'operational',
    features: [
      'Customers sync',
      'Products sync',
      'Sales management',
      'CRM integration',
      'Metrics aggregation',
      'Meta CAPI',
    ],
  })
}
